'use client';
import { Check, Clipboard } from 'lucide-react';
import {
  type ComponentProps,
  createContext,
  type HTMLAttributes,
  type ReactNode,
  type RefObject,
  useContext,
  useMemo,
  useRef,
  useState,
  useCallback,
  useEffect,
} from 'react';
import { cn } from '@/lib/utils';
import { useCopyButton } from '@/lib/fumadocs/utils/use-copy-button';
import { buttonVariants } from '@/components/fumadocs/button';
import {
  Tabs,
  TabsContent,
  TabsList,
  TabsTrigger,
} from '@/components/fumadocs/tabs.unstyled';
import { mergeRefs } from '@/lib/fumadocs/utils/merge-refs';

export interface EditableCodeBlockProps extends ComponentProps<'figure'> {
  /**
   * The code content to display and edit
   */
  code: string;

  /**
   * Callback when code is edited
   */
  onCodeChange?: (code: string) => void;

  /**
   * Language for syntax highlighting
   */
  lang?: string;

  /**
   * Icon of code block
   *
   * When passed as a string, it assumes the value is the HTML of icon
   */
  icon?: ReactNode;

  /**
   * Allow to copy code with copy button
   *
   * @defaultValue true
   */
  allowCopy?: boolean;

  /**
   * Enable editing mode
   *
   * @defaultValue false
   */
  editable?: boolean;

  /**
   * Keep original background color generated by Shiki or Rehype Code
   *
   * @defaultValue false
   */
  keepBackground?: boolean;

  /**
   * Enable word wrapping for long lines
   *
   * @defaultValue false
   */
  wordWrap?: boolean;

  viewportProps?: HTMLAttributes<HTMLElement>;

  /**
   * show line numbers
   */
  'data-line-numbers'?: boolean;

  /**
   * @defaultValue 1
   */
  'data-line-numbers-start'?: number;

  Actions?: (props: { className?: string; children?: ReactNode }) => ReactNode;
}

const WordWrapContext = createContext<boolean>(false);

export function Pre(props: ComponentProps<'pre'>) {
  const wordWrap = useContext(WordWrapContext);

  return (
    <pre
      {...props}
      className={cn(
        wordWrap ? 'w-auto' : 'min-w-full w-max',
        '*:flex *:flex-col',
        props.className
      )}
      style={{
        ...(wordWrap
          ? {
              whiteSpace: 'pre-wrap',
              wordBreak: 'break-word',
              tabSize: '2',
            }
          : undefined),
        ...props.style,
      }}
    >
      {props.children}
    </pre>
  );
}

function EditableCodeEditor({
  code,
  onCodeChange,
  wordWrap,
  viewportProps,
  dataLineNumbers,
  dataLineNumbersStart,
}: {
  code: string;
  onCodeChange?: (code: string) => void;
  wordWrap: boolean;
  viewportProps: HTMLAttributes<HTMLElement>;
  dataLineNumbers?: boolean;
  dataLineNumbersStart?: number;
}) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const highlightRef = useRef<HTMLDivElement>(null);

  const syncScroll = useCallback(() => {
    if (textareaRef.current && highlightRef.current) {
      highlightRef.current.scrollTop = textareaRef.current.scrollTop;
      highlightRef.current.scrollLeft = textareaRef.current.scrollLeft;
    }
  }, []);

  const handleChange = useCallback(
    (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      onCodeChange?.(e.target.value);
    },
    [onCodeChange]
  );

  useEffect(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;

    textarea.addEventListener('scroll', syncScroll);
    return () => textarea.removeEventListener('scroll', syncScroll);
  }, [syncScroll]);

  return (
    <div
      {...viewportProps}
      className={cn(
        'text-[13px] py-3.5 overflow-hidden max-h-[600px] fd-scroll-container relative',
        viewportProps.className
      )}
      style={
        {
          '--padding-right': 'calc(var(--spacing) * 8)',
          counterSet: dataLineNumbers
            ? `line ${Number(dataLineNumbersStart ?? 1) - 1}`
            : undefined,
          ...viewportProps.style,
        } as object
      }
    >
      <div className="relative w-full h-full">
        <textarea
          ref={textareaRef}
          value={code}
          onChange={handleChange}
          className={cn(
            'absolute inset-0 w-full h-full resize-none bg-transparent text-transparent caret-white',
            'font-mono p-0 m-0 border-0 outline-none',
            wordWrap ? 'whitespace-pre-wrap break-words' : 'whitespace-pre overflow-auto',
            'z-10'
          )}
          style={{
            tabSize: 2,
          }}
          spellCheck="false"
          autoCapitalize="off"
          autoCorrect="off"
          autoComplete="off"
        />

        <div
          ref={highlightRef}
          className={cn(
            'absolute inset-0 w-full h-full overflow-auto pointer-events-none',
            wordWrap ? 'whitespace-pre-wrap break-words' : 'whitespace-pre overflow-auto'
          )}
          style={{
            tabSize: 2,
          }}
        >
          <pre
            className={cn(
              'flex flex-col',
              wordWrap ? 'w-auto' : 'min-w-full w-max'
            )}
            style={{
              ...(wordWrap
                ? {
                    whiteSpace: 'pre-wrap',
                    wordBreak: 'break-word',
                    tabSize: '2',
                  }
                : undefined),
              margin: 0,
              padding: 0,
            }}
          >
            <code>
              {code.split('\n').map((line, i) => (
                <span key={i} className="line">
                  {line}
                </span>
              ))}
            </code>
          </pre>
        </div>
      </div>
    </div>
  );
}

export function EditableCodeBlock({
  ref,
  code,
  onCodeChange,
  lang = 'plaintext',
  allowCopy = true,
  editable = false,
  keepBackground = false,
  icon,
  wordWrap = false,
  viewportProps = {},
  children,
  Actions = (props) => (
    <div {...props} className={cn('empty:hidden', props.className)} />
  ),
  ...props
}: EditableCodeBlockProps) {
  const areaRef = useRef<HTMLDivElement>(null);
  const [displayCode, setDisplayCode] = useState(code);

  const handleCodeChange = useCallback(
    (newCode: string) => {
      setDisplayCode(newCode);
      onCodeChange?.(newCode);
    },
    [onCodeChange]
  );

  useEffect(() => {
    setDisplayCode(code);
  }, [code]);

  return (
    <figure
      ref={ref}
      dir="ltr"
      {...props}
      className={cn(
        'my-4 bg-fd-card rounded-xl',
        keepBackground && 'bg-(--shiki-light-bg) dark:bg-(--shiki-dark-bg)',
        'shiki relative border shadow-sm outline-none not-prose overflow-hidden text-sm',
        props.className
      )}
    >
      {editable ? (
        <>
          <div className="flex text-fd-muted-foreground items-center gap-2 h-9.5 border-b px-4">
            {typeof icon === 'string' ? (
              <div
                className="[&_svg]:size-3.5"
                dangerouslySetInnerHTML={{
                  __html: icon,
                }}
              />
            ) : (
              icon
            )}
            <span className="flex-1">{lang}</span>
            {Actions({
              className: '-me-2',
              children: allowCopy && (
                <CopyButton
                  containerRef={areaRef}
                  code={displayCode}
                />
              ),
            })}
          </div>
          <div ref={areaRef}>
            <EditableCodeEditor
              code={displayCode}
              onCodeChange={handleCodeChange}
              wordWrap={wordWrap}
              viewportProps={viewportProps}
              dataLineNumbers={props['data-line-numbers']}
              dataLineNumbersStart={props['data-line-numbers-start']}
            />
          </div>
        </>
      ) : (
        <>
          <div className="flex text-fd-muted-foreground items-center gap-2 h-9.5 border-b px-4">
            {typeof icon === 'string' ? (
              <div
                className="[&_svg]:size-3.5"
                dangerouslySetInnerHTML={{
                  __html: icon,
                }}
              />
            ) : (
              icon
            )}
            <figcaption className="flex-1 truncate">{lang}</figcaption>
            {Actions({
              className: '-me-2',
              children: allowCopy && (
                <CopyButton
                  containerRef={areaRef}
                  code={displayCode}
                />
              ),
            })}
          </div>
          <div
            ref={areaRef}
            {...viewportProps}
            className={cn(
              'text-[13px] py-3.5 overflow-auto max-h-[600px] fd-scroll-container',
              viewportProps.className
            )}
            style={
              {
                '--padding-right': 'calc(var(--spacing) * 8)',
                counterSet: props['data-line-numbers']
                  ? `line ${Number(props['data-line-numbers-start'] ?? 1) - 1}`
                  : undefined,
                ...viewportProps.style,
              } as object
            }
          >
            <WordWrapContext.Provider value={wordWrap}>
              {children || (
                <Pre>
                  <code>
                    {displayCode.split('\n').map((line, i) => (
                      <span key={i} className="line">
                        {line}
                      </span>
                    ))}
                  </code>
                </Pre>
              )}
            </WordWrapContext.Provider>
          </div>
        </>
      )}
    </figure>
  );
}

function CopyButton({
  className,
  containerRef,
  code,
  ...props
}: ComponentProps<'button'> & {
  containerRef: RefObject<HTMLElement | null>;
  code?: string;
}) {
  const [checked, onClick] = useCopyButton(() => {
    if (code !== undefined) {
      void navigator.clipboard.writeText(code);
      return;
    }

    const pre = containerRef.current?.getElementsByTagName('pre').item(0);
    if (!pre) return;

    const clone = pre.cloneNode(true) as HTMLElement;
    clone.querySelectorAll('.nd-copy-ignore').forEach((node) => {
      node.replaceWith('\n');
    });

    void navigator.clipboard.writeText(clone.textContent ?? '');
  });

  return (
    <button
      type="button"
      data-checked={checked || undefined}
      className={cn(
        buttonVariants({
          className:
            'hover:text-fd-accent-foreground data-checked:text-fd-accent-foreground',
          size: 'icon-xs',
        }),
        className
      )}
      aria-label={checked ? 'Copied Text' : 'Copy Text'}
      onClick={onClick}
      {...props}
    >
      {checked ? <Check /> : <Clipboard />}
    </button>
  );
}

export function CodeBlockTabs({ ref, ...props }: ComponentProps<typeof Tabs>) {
  const containerRef = useRef<HTMLDivElement>(null);

  return (
    <Tabs
      ref={mergeRefs(containerRef, ref)}
      {...props}
      className={cn(
        'bg-fd-card rounded-xl border my-4',
        props.className
      )}
    >
      {props.children}
    </Tabs>
  );
}

export function CodeBlockTabsList(props: ComponentProps<typeof TabsList>) {
  return (
    <TabsList
      {...props}
      className={cn(
        'flex flex-row px-2 overflow-x-auto text-fd-muted-foreground',
        props.className
      )}
    >
      {props.children}
    </TabsList>
  );
}

export function CodeBlockTabsTrigger({
  children,
  ...props
}: ComponentProps<typeof TabsTrigger>) {
  return (
    <TabsTrigger
      {...props}
      className={cn(
        'relative group inline-flex text-sm font-medium text-nowrap items-center transition-colors gap-2 px-2 py-1.5 hover:text-fd-accent-foreground data-[state=active]:text-fd-primary [&_svg]:size-3.5',
        props.className
      )}
    >
      <div className="absolute inset-x-2 bottom-0 h-px group-data-[state=active]:bg-fd-primary" />
      {children}
    </TabsTrigger>
  );
}

export function CodeBlockTab(props: ComponentProps<typeof TabsContent>) {
  return <TabsContent {...props} />;
}